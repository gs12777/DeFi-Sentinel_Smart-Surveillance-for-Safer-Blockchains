{"ast":null,"code":"import { ethers } from 'ethers';\nconst INFURA_KEY = process.env.REACT_APP_INFURA_KEY;\nconst API_BASE_URL = \"http://127.0.0.1:5000\";\nif (!INFURA_KEY) {\n  throw new Error(\"❌ Missing INFURA API Key. Please check your .env file.\");\n}\nconst provider = new ethers.JsonRpcProvider(`https://sepolia.infura.io/v3/${INFURA_KEY}`);\n\n// List of verified contracts\nconst VERIFIED_CONTRACTS = ['0xdac17f958d2ee523a2206206994597c13d831ec7'];\n\n// ✅ Helper functions\nconst isValidEthereumAddress = address => ethers.isAddress(address);\nconst formatEtherValue = weiValue => parseFloat(ethers.formatEther(weiValue)).toFixed(6);\nconst formatGweiValue = weiValue => parseFloat(ethers.formatUnits(weiValue, \"gwei\")).toFixed(6);\n\n// ✅ Get transaction details from blockchain\nconst getTransaction = async txHash => {\n  try {\n    if (!txHash || typeof txHash !== \"string\") throw new Error(\"❌ Invalid transaction hash.\");\n    const transaction = await provider.getTransaction(txHash);\n    if (!transaction) throw new Error(\"❌ Transaction not found.\");\n    const block = await provider.getBlock(transaction.blockNumber);\n    const timestamp = (block === null || block === void 0 ? void 0 : block.timestamp) || Math.floor(Date.now() / 1000);\n    return {\n      hash: transaction.hash,\n      from: transaction.from,\n      to: transaction.to || \"N/A\",\n      value: formatEtherValue(transaction.value),\n      gasPrice: formatGweiValue(transaction.gasPrice),\n      ageHours: ((Date.now() / 1000 - timestamp) / 3600).toFixed(2)\n    };\n  } catch (error) {\n    console.error(\"❌ Error fetching transaction:\", error);\n    return null;\n  }\n};\n\n// ✅ Fraud Risk Calculation Function (Rule-based + AI-based)\nconst checkFraudRisk = async txData => {\n  try {\n    if (!isValidEthereumAddress(txData.from)) throw new Error(`❌ Invalid sender address: ${txData.from}`);\n    if (txData.to && !isValidEthereumAddress(txData.to)) throw new Error(`❌ Invalid recipient address: ${txData.to}`);\n    const senderTxCount = await provider.getTransactionCount(txData.from);\n    const recentTxs = await provider.getLogs({\n      fromBlock: 'latest',\n      address: txData.from\n    });\n\n    // Define Risk Rules\n    const SEPOLIA_RULES = {\n      HIGH_VALUE: 0.3,\n      HIGH_GAS: 3,\n      NEW_ACCOUNT: 3,\n      FREQUENT_TX: 5\n    };\n    let ruleBasedRisk = 0;\n    const flags = {};\n    const value = parseFloat(txData.value);\n    const gasPrice = parseFloat(txData.gasPrice);\n    if (value === 0) {\n      ruleBasedRisk += 45;\n      flags.zeroValue = true;\n    }\n    if (txData.to && !VERIFIED_CONTRACTS.includes(txData.to)) {\n      ruleBasedRisk += 30;\n      flags.unverifiedContract = true;\n    }\n    if (value > SEPOLIA_RULES.HIGH_VALUE) {\n      ruleBasedRisk += 40;\n      flags.highValue = true;\n    }\n    if (gasPrice > SEPOLIA_RULES.HIGH_GAS) {\n      ruleBasedRisk += 35;\n      flags.highGas = true;\n    }\n    if (senderTxCount < SEPOLIA_RULES.NEW_ACCOUNT) {\n      ruleBasedRisk += 30;\n      flags.newAccount = true;\n    }\n    if (recentTxs.length > SEPOLIA_RULES.FREQUENT_TX) {\n      ruleBasedRisk += 25;\n      flags.frequentTransactions = true;\n    }\n    const ageWeight = Math.max(0, 10 - parseFloat(txData.ageHours) / 3);\n    ruleBasedRisk += ageWeight;\n    if (parseFloat(txData.ageHours) > 3 && ruleBasedRisk > 20) ruleBasedRisk += 10, flags.oldTransaction = true;\n\n    // ✅ AI Prediction (Calling Flask API)\n    const aiPrediction = await getAIPrediction(txData);\n    return {\n      ruleBasedRisk: Math.min(ruleBasedRisk, 100).toFixed(2),\n      aiBasedRisk: aiPrediction.fraud_probability.toFixed(2),\n      isFraud: aiPrediction.is_fraud,\n      flags\n    };\n  } catch (error) {\n    console.error(\"❌ Fraud analysis failed:\", error);\n    return {\n      ruleBasedRisk: \"0%\",\n      aiBasedRisk: \"0%\",\n      isFraud: false,\n      flags: {}\n    };\n  }\n};\n\n// ✅ Function to Call Flask API\nconst getAIPrediction = async txData => {\n  try {\n    const response = await fetch(`${API_BASE_URL}/predict`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        tx_value_eth: txData.value,\n        gas_price_gwei: txData.gasPrice,\n        time_since_last_tx: txData.ageHours,\n        num_transactions_per_address: 50,\n        account_age_days: 365,\n        gas_fee_ratio: 0.02\n      })\n    });\n    if (!response.ok) {\n      throw new Error(\"❌ AI model prediction failed.\");\n    }\n    return await response.json();\n  } catch (error) {\n    console.error(\"❌ AI prediction error:\", error);\n    return {\n      is_fraud: false,\n      fraud_probability: 0\n    };\n  }\n};\n\n// ✅ Export Service\nconst BlockchainService = {\n  checkFraudRisk,\n  getTransaction\n};\nexport default BlockchainService;","map":{"version":3,"names":["ethers","INFURA_KEY","process","env","REACT_APP_INFURA_KEY","API_BASE_URL","Error","provider","JsonRpcProvider","VERIFIED_CONTRACTS","isValidEthereumAddress","address","isAddress","formatEtherValue","weiValue","parseFloat","formatEther","toFixed","formatGweiValue","formatUnits","getTransaction","txHash","transaction","block","getBlock","blockNumber","timestamp","Math","floor","Date","now","hash","from","to","value","gasPrice","ageHours","error","console","checkFraudRisk","txData","senderTxCount","getTransactionCount","recentTxs","getLogs","fromBlock","SEPOLIA_RULES","HIGH_VALUE","HIGH_GAS","NEW_ACCOUNT","FREQUENT_TX","ruleBasedRisk","flags","zeroValue","includes","unverifiedContract","highValue","highGas","newAccount","length","frequentTransactions","ageWeight","max","oldTransaction","aiPrediction","getAIPrediction","min","aiBasedRisk","fraud_probability","isFraud","is_fraud","response","fetch","method","headers","body","JSON","stringify","tx_value_eth","gas_price_gwei","time_since_last_tx","num_transactions_per_address","account_age_days","gas_fee_ratio","ok","json","BlockchainService"],"sources":["C:/Users/gurus/New fold/blockchain-fraud-detect-new/frontend/src/services/BlockchainService.js"],"sourcesContent":["import { ethers } from 'ethers';\r\n\r\nconst INFURA_KEY = process.env.REACT_APP_INFURA_KEY;\r\nconst API_BASE_URL = \"http://127.0.0.1:5000\";\r\n\r\nif (!INFURA_KEY) {\r\n  throw new Error(\"❌ Missing INFURA API Key. Please check your .env file.\");\r\n}\r\n\r\nconst provider = new ethers.JsonRpcProvider(\r\n  `https://sepolia.infura.io/v3/${INFURA_KEY}`\r\n);\r\n\r\n// List of verified contracts\r\nconst VERIFIED_CONTRACTS = ['0xdac17f958d2ee523a2206206994597c13d831ec7'];\r\n\r\n// ✅ Helper functions\r\nconst isValidEthereumAddress = (address) => ethers.isAddress(address);\r\nconst formatEtherValue = (weiValue) => parseFloat(ethers.formatEther(weiValue)).toFixed(6);\r\nconst formatGweiValue = (weiValue) => parseFloat(ethers.formatUnits(weiValue, \"gwei\")).toFixed(6);\r\n\r\n// ✅ Get transaction details from blockchain\r\nconst getTransaction = async (txHash) => {\r\n  try {\r\n    if (!txHash || typeof txHash !== \"string\") throw new Error(\"❌ Invalid transaction hash.\");\r\n    \r\n    const transaction = await provider.getTransaction(txHash);\r\n    if (!transaction) throw new Error(\"❌ Transaction not found.\");\r\n\r\n    const block = await provider.getBlock(transaction.blockNumber);\r\n    const timestamp = block?.timestamp || Math.floor(Date.now() / 1000);\r\n\r\n    return {\r\n      hash: transaction.hash,\r\n      from: transaction.from,\r\n      to: transaction.to || \"N/A\",\r\n      value: formatEtherValue(transaction.value),\r\n      gasPrice: formatGweiValue(transaction.gasPrice),\r\n      ageHours: ((Date.now() / 1000 - timestamp) / 3600).toFixed(2)\r\n    };\r\n  } catch (error) {\r\n    console.error(\"❌ Error fetching transaction:\", error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// ✅ Fraud Risk Calculation Function (Rule-based + AI-based)\r\nconst checkFraudRisk = async (txData) => {\r\n  try {\r\n    if (!isValidEthereumAddress(txData.from)) throw new Error(`❌ Invalid sender address: ${txData.from}`);\r\n    if (txData.to && !isValidEthereumAddress(txData.to)) throw new Error(`❌ Invalid recipient address: ${txData.to}`);\r\n\r\n    const senderTxCount = await provider.getTransactionCount(txData.from);\r\n    const recentTxs = await provider.getLogs({ fromBlock: 'latest', address: txData.from });\r\n\r\n    // Define Risk Rules\r\n    const SEPOLIA_RULES = { HIGH_VALUE: 0.3, HIGH_GAS: 3, NEW_ACCOUNT: 3, FREQUENT_TX: 5 };\r\n    let ruleBasedRisk = 0;\r\n    const flags = {};\r\n\r\n    const value = parseFloat(txData.value);\r\n    const gasPrice = parseFloat(txData.gasPrice);\r\n\r\n    if (value === 0) {\r\n      ruleBasedRisk += 45;\r\n      flags.zeroValue = true;\r\n    }\r\n    \r\n    if (txData.to && !VERIFIED_CONTRACTS.includes(txData.to)) {\r\n      ruleBasedRisk += 30;\r\n      flags.unverifiedContract = true;\r\n    }\r\n    \r\n    if (value > SEPOLIA_RULES.HIGH_VALUE) {\r\n      ruleBasedRisk += 40;\r\n      flags.highValue = true;\r\n    }\r\n    \r\n    if (gasPrice > SEPOLIA_RULES.HIGH_GAS) {\r\n      ruleBasedRisk += 35;\r\n      flags.highGas = true;\r\n    }\r\n    \r\n    if (senderTxCount < SEPOLIA_RULES.NEW_ACCOUNT) {\r\n      ruleBasedRisk += 30;\r\n      flags.newAccount = true;\r\n    }\r\n    \r\n    if (recentTxs.length > SEPOLIA_RULES.FREQUENT_TX) {\r\n      ruleBasedRisk += 25;\r\n      flags.frequentTransactions = true;\r\n    }\r\n\r\n    const ageWeight = Math.max(0, 10 - (parseFloat(txData.ageHours) / 3));\r\n    ruleBasedRisk += ageWeight;\r\n    if (parseFloat(txData.ageHours) > 3 && ruleBasedRisk > 20) ruleBasedRisk += 10, flags.oldTransaction = true;\r\n\r\n    // ✅ AI Prediction (Calling Flask API)\r\n    const aiPrediction = await getAIPrediction(txData);\r\n    \r\n    return {\r\n      ruleBasedRisk: Math.min(ruleBasedRisk, 100).toFixed(2),\r\n      aiBasedRisk: aiPrediction.fraud_probability.toFixed(2),\r\n      isFraud: aiPrediction.is_fraud,\r\n      flags\r\n    };\r\n  } catch (error) {\r\n    console.error(\"❌ Fraud analysis failed:\", error);\r\n    return { ruleBasedRisk: \"0%\", aiBasedRisk: \"0%\", isFraud: false, flags: {} };\r\n  }\r\n};\r\n\r\n// ✅ Function to Call Flask API\r\nconst getAIPrediction = async (txData) => {\r\n  try {\r\n    const response = await fetch(`${API_BASE_URL}/predict`, {\r\n      method: \"POST\",\r\n      headers: { \"Content-Type\": \"application/json\" },\r\n      body: JSON.stringify({\r\n        tx_value_eth: txData.value,\r\n        gas_price_gwei: txData.gasPrice,\r\n        time_since_last_tx: txData.ageHours,\r\n        num_transactions_per_address: 50, \r\n        account_age_days: 365, \r\n        gas_fee_ratio: 0.02\r\n      })\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(\"❌ AI model prediction failed.\");\r\n    }\r\n\r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error(\"❌ AI prediction error:\", error);\r\n    return { is_fraud: false, fraud_probability: 0 };\r\n  }\r\n};\r\n\r\n// ✅ Export Service\r\nconst BlockchainService = { checkFraudRisk, getTransaction };\r\nexport default BlockchainService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}